<!DOCTYPE html>
<html lang="en-US"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="template-info" file-name="empty.htm" version="2024-08-07" editor="USP" />
<meta name="author" content="USP" />
<meta name="creation-date" content="2024-10-30" />
<meta name="editor" content="USP" />
<meta name="change-date" content="2024-10-30" />
<meta name="version" content="1" />
<meta name="sectionTitle" content="../title.svg" />

<link rel="icon" type="image/svg+xml" href="/favicon.svg" sizes="all" />
<link rel="stylesheet" href="/inc/web-cat/page-structure/tutorial-page-1.css" />
<script type="module" src="/inc/web-cat/page-structure/tutorial-page-1.js" ></script>
 
<meta name="categories" content="Projects > Web > Content Authoring Toolbox" />
<meta name="tags" content="web, content, autoring, toolbox, HTML, JavaScript, CSS, WebCAT, component, highlight, link, target, hash" />
<meta name="description" content='This component smoothly scrolls a link target element into view. The target element ID is specified in the document fragment portion or a URL (the so-called "hash") in the document URL or the href attribute of a link anchor.' />

<title>Link Target Scrolling (Web > Content Authoring Toolbox)</title>

</head><body>

<h1>Link Target Scrolling</h1>

<p id="pageAbstract"></p>

<h2 cbc>Using the Component</h2><div>

<p>The component consists of a single file:</p>

<ul>
<li>highlight-link-target.js</li>
</ul>

<p>For detailed notes on how to import this file into a document or aggregation file, refer to <a hef="../component-anatomy.htm#using">WebCAT Component Anatomy</a>.</p>

<p>You don't have to change anything to your HTML code. Anchor elements are processed automatically if they address an element on the same page:</p>

<figure class="listing"><figcaption>Link target element</figcaption>
<pre>
&lt;a href="<hi>#element-id</hi>"&gt;Jump to element&lt;/a&gt; in the same document
&lt;a href="path/to/document.htm"<hi>#element-id</hi>"&gt;Jump to element&lt;/a&gt; in a different document
</pre></figure>

<p>A click on a link should carry you to the corresponding entry in the description list. The module script extracts the hash part from the URL, locates the related element in the document, and scrolles it smoothly into view.</p>

<p>Click on the "entry" links and notice the document scrolling down:</p>

<figure class="demo" style="scroll-margin-top:40px"><figcaption>Smooth scrolling demo</figcaption>
<iframe style="width:100% ; height:200px" src="demo-1.htm"></iframe>
</figure>

<p>Note that scrolling functions in IFRAME-hosted documents interact with the host document, so I recommend to test <a href="demo-1.htm" target="_blank">demo-1</a> and <a href="demo-1-linklist.htm" target="_blank">demo-1-linklist</a> in a separate browser window.</p>

<!--h2--Using the Component--></div>

<h2 cbc="collapsed">Module Configuration</h2><div>

<p>Module script parameters are passed in the query string of the script URL, as described in <a href="../component-anatomy.htm#passing-parameters">Anatomy of a WebCAT Component</a>.</p>

<dl>
<dt>scroll-margin-top</dt><dd>
	<p>Vertical distance of the target element from the window top after scrolling into view.</p>
	<p>Default value: 20</p>
	</dd>
<dt>restore-hash</dt><dd>
	<p>Restores the document fragment identifier ("hash") in the document URL after the document has been loaded.</p>
	</dd>
</dl>

<!--h2--Module Configuration--></div>

<h2 cbc="collapsed">Implementation Details</h2><div>

<p>First finding: The function <tt>element.scrollIntoView()</tt> cannot be used inside <tt>IFRAME</tt> hosted documents, because the function scrolls both the hosted <em>and</em> the host document. Instead, <tt>document.scrollingElement.scroll()</tt> must be used.</p>

<p>Smooth scrolling to an element in a different document (href="different.htm#elementID") usually fails, because the browser has already positioned the document before <tt>document.scrollingElement.scroll()</tt> is exeuted &ndash; and therefore the function call has <em>no effect</em>.</p>

<p>The implementation idea is to save and clear <tt>document.location.hash</tt> at an early stage in the loading process. This actually scrolls the document back to the top, but the effect is not visible to the user because the document has not yet been rendered. Therefore there is no (additional) flicker or flash effect when the document loads. </p>

<p>Now we can smoothly scroll to the link target element with <tt>document.scrollingElement.scroll( )</tt>.</p>

<p>If the documents in question are hosted in an IFRAME in another host document, timing issues appear: The function call <tt>document.scrollingElement.scroll( )</tt> has no effect. Therefore, the entire component initialization is delayed:</p>

<figure class="listing"><figcaption>Delayed initialization</figcaption>
<pre>
<cc>/** Module init code */</cc> 
const linkTargetElementSelector = document.location.hash;
document.location.hash = "" ;  
<hi>requestAnimationFrame</hi>( ( ) => { 
<hi>requestAnimationFrame</hi>( ( ) => { 
	initializer.initComponent( init, import.meta.url );
	} );
	} );
</pre></figure>

<p>This works well if the document is really <em>loaded</em>, but the approach fails if a link anchor navigates the browser to an element <em>on the same page</em>. Therefore, the module script sets up an event handler to catch clicks on anchor elements with link targets on the same page, abort the default behaviour and smoothly scrolls to the target element programmatically.</p>

<p>Note: <tt>element.style.scrollMarginTop</tt> prevents that the element is scrolled to the top of the window, leaving space sticky elements at the top of the window, like toolbars or menus.</p>

<p class="note">Note: The <a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API">view transitions API</a> might be a better option for this purpose.</p>

<!--h2--Implementation Details--></div>

</body></html>